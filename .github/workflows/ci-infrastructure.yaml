name: 2 - Provisioning Infrastructure

on:
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  pull-requests: write
  security-events: write
  actions: write
  checks: write
  issues: write

jobs:
  iam:
    name: Provisioning Permissions IAM
    runs-on: ubuntu-latest
    environment: prd
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.13

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AW_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: ${{ secrets.AWS_STS }}
          role-session-name: GitHubActions-${{github.run_id}}

      - name: Terraform Format Check IAM
        uses: dflook/terraform-fmt-check@v1
        with:
          path: terraform/production/iam

      - name: Provision Permissions IAM Initial Setup
        working-directory: terraform/production/iam
        run: terraform init -input=false -no-color

      - name: Provision Permissions Plan (with error output)
        working-directory: terraform/production/iam
        run: |
          terraform plan -out=tfplan || (echo "Plan failed, see above for details." && exit 1)

      - name: Import existing IAM resources if needed and apply
        working-directory: terraform/production/iam
        run: |
          echo "Checking for IAM resources that need to be imported..."

          # Check and import ec2-ssm-fast-api role
          if terraform state show "aws_iam_role.ec2_ssm_role" &>/dev/null; then
            echo "✓ EC2 SSM Role already in Terraform state"
          else
            echo "→ EC2 SSM Role not in state, attempting import..."
            terraform import aws_iam_role.ec2_ssm_role ec2-ssm-fast-api || echo "⚠ Import failed or resource doesn't exist, will try to create"
          fi

          # Check and import ec2-ssm-fast-api-profile
          if terraform state show "aws_iam_instance_profile.ec2_ssm_profile" &>/dev/null; then
            echo "✓ EC2 SSM Instance Profile already in Terraform state"
          else
            echo "→ EC2 SSM Instance Profile not in state, attempting import..."
            terraform import aws_iam_instance_profile.ec2_ssm_profile ec2-ssm-fast-api-profile || echo "⚠ Import failed or resource doesn't exist, will try to create"
          fi

          # Check and import self-hosted-runner role
          if terraform state show "aws_iam_role.self_hosted_runner" &>/dev/null; then
            echo "✓ Self-Hosted Runner Role already in Terraform state"
          else
            echo "→ Self-Hosted Runner Role not in state, attempting import..."
            terraform import aws_iam_role.self_hosted_runner self-hosted-role || echo "⚠ Import failed or resource doesn't exist, will try to create"
          fi

          # Check and import self-hosted-runner instance profile
          if terraform state show "aws_iam_instance_profile.self_hosted_runner_profile" &>/dev/null; then
            echo "✓ Self-Hosted Runner Instance Profile already in Terraform state"
          else
            echo "→ Self-Hosted Runner Instance Profile not in state, attempting import..."
            terraform import aws_iam_instance_profile.self_hosted_runner_profile self-hosted-role || echo "⚠ Import failed or resource doesn't exist, will try to create"
          fi

          # Note: GitHub Actions OIDC role data source doesn't need import
          # The policy attachment for Secrets Manager will be created fresh
          echo "→ GitHub Actions Secrets Manager policy will be created (no import needed for new policies)"

          echo "Import checks completed. Applying changes..."
          terraform apply -auto-approve || (echo "Apply failed, see above for details." && exit 1)
      # Manual rollback: If a resource fails, you can run
      # terraform destroy -target=<resource_address> in the working directory to clean up.
  sqs:
    name: Provisioning SQS Infrastructure
    runs-on: ubuntu-latest
    environment: prd
    needs: iam
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.13

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AW_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: ${{ secrets.AWS_STS }}
          role-session-name: GitHubActions-${{github.run_id}}

      - name: Terraform Format Check SQS
        uses: dflook/terraform-fmt-check@v1
        with:
          path: terraform/production/sqs-notifications

      - name: Provision SQS Initial Setup
        working-directory: terraform/production/sqs-notifications
        run: terraform init -input=false -no-color

      - name: Provision SQS Plan
        working-directory: terraform/production/sqs-notifications
        run: terraform plan -out=tfplan

      - name: Import existing SQS resources if needed and apply
        working-directory: terraform/production/sqs-notifications
        run: |
          echo "Checking for SQS resources that need to be imported..."

          # Check and import SQS queue
          if terraform state show "aws_sqs_queue.file_upload_queue" &>/dev/null; then
            echo "✓ SQS queue already in Terraform state"
          else
            echo "→ SQS queue not in state, attempting import..."
            terraform import aws_sqs_queue.file_upload_queue file-upload-queue || echo "⚠ Import failed or resource doesn't exist, will try to create"
          fi

          echo "Import checks completed. Applying changes..."
          terraform apply -auto-approve

  s3:
    name: Provisioning S3 Bucket
    runs-on: ubuntu-latest
    environment: prd
    needs: [iam, sqs]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.13

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AW_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: ${{ secrets.AWS_STS }}
          role-session-name: GitHubActions-${{github.run_id}}

      - name: Terraform Format Check S3
        uses: dflook/terraform-fmt-check@v1
        with:
          path: terraform/production/s3-storage

      - name: Provision S3 Initial Setup
        working-directory: terraform/production/s3-storage
        run: terraform init -input=false -no-color

      - name: Provision S3 Plan
        working-directory: terraform/production/s3-storage
        run: terraform plan -out=tfplan

      - name: Import existing S3 resources if needed and apply
        working-directory: terraform/production/s3-storage
        run: |
          echo "Checking for S3 resources that need to be imported..."

          # Check and import S3 bucket
          if terraform state show "aws_s3_bucket.storage_files_csv" &>/dev/null; then
            echo "✓ S3 bucket already in Terraform state"
          else
            echo "→ S3 bucket not in state, attempting import..."
            terraform import aws_s3_bucket.storage_files_csv storage-files-csv || echo "⚠ Bucket import failed"
          fi

          # Check and import S3 public access block
          if terraform state show "aws_s3_bucket_public_access_block.storage_files_csv_block" &>/dev/null; then
            echo "✓ S3 public access block already in Terraform state"
          else
            echo "→ S3 public access block not in state, attempting import..."
            terraform import aws_s3_bucket_public_access_block.storage_files_csv_block storage-files-csv || echo "⚠ Public access block import failed"
          fi

          # Check and import S3 encryption configuration
          if terraform state show "aws_s3_bucket_server_side_encryption_configuration.storage_files_csv_encryption" &>/dev/null; then
            echo "✓ S3 encryption configuration already in Terraform state"
          else
            echo "→ S3 encryption configuration not in state, attempting import..."
            terraform import aws_s3_bucket_server_side_encryption_configuration.storage_files_csv_encryption storage-files-csv || echo "⚠ Encryption import failed"
          fi

          # Check and import S3 lifecycle configuration
          if terraform state show "aws_s3_bucket_lifecycle_configuration.storage_files_csv_lifecycle" &>/dev/null; then
            echo "✓ S3 lifecycle configuration already in Terraform state"
          else
            echo "→ S3 lifecycle configuration not in state, attempting import..."
            terraform import aws_s3_bucket_lifecycle_configuration.storage_files_csv_lifecycle storage-files-csv || echo "⚠ Lifecycle import failed"
          fi

          # Check and import S3 bucket policy
          if terraform state show "aws_s3_bucket_policy.storage_files_csv_policy" &>/dev/null; then
            echo "✓ S3 bucket policy already in Terraform state"
          else
            echo "→ S3 bucket policy not in state, attempting import..."
            terraform import aws_s3_bucket_policy.storage_files_csv_policy storage-files-csv || echo "⚠ Policy import failed"
          fi

          # Check and import S3 bucket notification
          if terraform state show "aws_s3_bucket_notification.files_csv_notification" &>/dev/null; then
            echo "✓ S3 bucket notification already in Terraform state"
          else
            echo "→ S3 bucket notification not in state, attempting import..."
            terraform import aws_s3_bucket_notification.files_csv_notification storage-files-csv || echo "⚠ Notification import failed"
          fi

          echo "Import checks completed. Applying changes..."
          terraform apply -auto-approve

  secreter-manager-fast-api:
    name: Provisioning Secrets Manager Fast API Infrastructure
    runs-on: ubuntu-latest
    environment: prd
    needs: iam
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.13

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AW_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: ${{ secrets.AWS_STS }}
          role-session-name: GitHubActions-${{github.run_id}}

      - name: Terraform Format Check Secrets Manager Fast API
        uses: dflook/terraform-fmt-check@v1
        with:
          path: terraform/production/secret-manager

      - name: Provision Secret manager Initial Setup
        working-directory: terraform/production/secret-manager
        run: terraform init -input=false -no-color

      - name: Provision Secret manager Plan
        working-directory: terraform/production/secret-manager
        env:
          TF_VAR_secret_key: ${{ secrets.JWT_SECRET_KEY }}
          TF_VAR_algorithm: ${{ secrets.JWT_ALGORITHM }}
          TF_VAR_user_name: ${{ secrets.APP_USER_NAME }}
          TF_VAR_password: ${{ secrets.APP_PASSWORD }}
          TF_VAR_url_base: ${{ secrets.APP_URL_BASE }}
        run: terraform plan

      - name: Import existing Secrets Manager resources if needed and apply
        working-directory: terraform/production/secret-manager
        env:
          TF_VAR_secret_key: ${{ secrets.JWT_SECRET_KEY }}
          TF_VAR_algorithm: ${{ secrets.JWT_ALGORITHM }}
          TF_VAR_user_name: ${{ secrets.APP_USER_NAME }}
          TF_VAR_password: ${{ secrets.APP_PASSWORD }}
          TF_VAR_url_base: ${{ secrets.APP_URL_BASE }}
        run: |
          echo "Checking for Secrets Manager resources that need to be imported..."

          # Check if secret exists in AWS first
          SECRET_EXISTS=$(aws secretsmanager describe-secret --secret-id fast-api-jwt-app 2>/dev/null && echo "yes" || echo "no")

          if [ "$SECRET_EXISTS" = "yes" ]; then
            echo "→ Secret exists in AWS"

            # Check if it's in Terraform state
            if terraform state show "aws_secretsmanager_secret.fast_api_credentials" &>/dev/null; then
              echo "✓ Secret already in Terraform state"
            else
              echo "→ Secret not in Terraform state, importing..."
              if terraform import aws_secretsmanager_secret.fast_api_credentials fast-api-jwt-app; then
                echo "✓ Secret imported successfully"
              else
                echo "⚠ Import failed. Checking if it's already managed elsewhere..."
                # Try to refresh state to see if it appears
                terraform refresh || true
                # Check again if it's in state now
                if terraform state show "aws_secretsmanager_secret.fast_api_credentials" &>/dev/null; then
                  echo "✓ Secret is now in state after refresh"
                else
                  echo "ERROR: Secret exists in AWS but cannot be imported to Terraform state."
                  echo "This usually means:"
                  echo "1. The secret is managed by another Terraform workspace/state"
                  echo "2. There's a permissions issue"
                  echo "3. The state file is corrupted"
                  echo ""
                  echo "Attempting to continue with apply - Terraform will handle the conflict..."
                fi
              fi
            fi

            # Check and import secret version
            if terraform state show "aws_secretsmanager_secret_version.fast_api_credentials_version" &>/dev/null; then
              echo "✓ Secret version already in Terraform state"
            else
              echo "→ Secret version not in Terraform state, importing..."
              # Get the secret ARN for version import
              SECRET_ARN=$(aws secretsmanager describe-secret --secret-id fast-api-jwt-credentials --query 'ARN' --output text)
              if terraform import "aws_secretsmanager_secret_version.fast_api_credentials_version" "${SECRET_ARN}|AWSCURRENT"; then
                echo "✓ Secret version imported successfully"
              else
                echo "⚠ Secret version import failed, will be managed on next apply"
              fi
            fi
          else
            echo "→ Secret doesn't exist in AWS, will be created"
          fi

          echo "Import checks completed. Applying changes..."
          echo "⚠️  NOTE: Applying without plan file to use current state after imports"
          terraform apply -auto-approve

  ec2-fast-api:
    name: Provisioning EC2 Fast API Infrastructure
    runs-on: ubuntu-latest
    environment: prd
    needs: [iam, secreter-manager-fast-api]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.13

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AW_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: ${{ secrets.AWS_STS }}
          role-session-name: GitHubActions-${{github.run_id}}

      - name: Terraform Format Check EC2 Fast API
        uses: dflook/terraform-fmt-check@v1
        with:
          path: terraform/production/ec2-fast-api-jwt
      - name: Provision EC2 Fast API Initial Setup
        working-directory: terraform/production/ec2-fast-api-jwt
        run: terraform init -input=false -no-color

      - name: Provision EC2 Fast API Plan
        working-directory: terraform/production/ec2-fast-api-jwt
        run: terraform plan -out=tfplan

      - name: Import existing EC2 Fast API resources if needed and apply
        working-directory: terraform/production/ec2-fast-api-jwt
        run: |
          echo "Checking for EC2 Fast API resources that need to be imported..."

          # Check and import security group
          if terraform state show "aws_security_group.fast_api_jwt_sg" &>/dev/null; then
            echo "✓ Security group already in Terraform state"
          else
            echo "→ Security group not in state, checking AWS..."
            SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=fast-api-jwt-sg" --query "SecurityGroups[0].GroupId" --output text 2>/dev/null)
            if [ "$SG_ID" != "None" ] && [ -n "$SG_ID" ]; then
              echo "→ Found security group $SG_ID in AWS, importing..."
              terraform import aws_security_group.fast_api_jwt_sg "$SG_ID" || echo "⚠ Security group import failed"
            else
              echo "→ Security group doesn't exist in AWS, will be created"
            fi
          fi

          # Check and import EC2 instance
          if terraform state show "aws_instance.fast_api_jwt" &>/dev/null; then
            echo "✓ EC2 instance already in Terraform state"
          else
            echo "→ EC2 instance not in state, checking AWS..."
            INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=fast-api-jwt" "Name=instance-state-name,Values=running,stopped" --query "Reservations[0].Instances[0].InstanceId" --output text 2>/dev/null)
            if [ "$INSTANCE_ID" != "None" ] && [ -n "$INSTANCE_ID" ]; then
              echo "→ Found instance $INSTANCE_ID in AWS, importing..."
              terraform import aws_instance.fast_api_jwt "$INSTANCE_ID" || echo "⚠ Instance import failed"
            else
              echo "→ EC2 instance doesn't exist in AWS, will be created"
            fi
          fi

          # Check and import IAM role policy attachment
          if terraform state show "aws_iam_role_policy_attachment.ec2_ssm_policy" &>/dev/null; then
            echo "✓ IAM role policy attachment already in Terraform state"
          else
            echo "→ IAM role policy attachment not in state, attempting import..."
            terraform import aws_iam_role_policy_attachment.ec2_ssm_policy ec2-ssm-fast-api/arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore || echo "⚠ Policy attachment import failed"
          fi

          echo "Import checks completed. Applying changes..."
          terraform apply -auto-approve

  ec2-self-hosted:
    name: Provisioning EC2 Self Hosted Runner Infrastructure
    runs-on: ubuntu-latest
    environment: prd
    needs: [iam, secreter-manager-fast-api]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.13

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AW_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: ${{ secrets.AWS_STS }}
          role-session-name: GitHubActions-${{github.run_id}}

      - name: Terraform Format Check EC2 Self Hosted Runner
        uses: dflook/terraform-fmt-check@v1
        with:
          path: terraform/production/ec2-self-hosted
      - name: Provision EC2 Self Hosted Runner Initial Setup
        working-directory: terraform/production/ec2-self-hosted
        run: terraform init -input=false -no-color


      - name: Create runner registration token
        id: create_token
        run: |
           # Request a repository-level registration token for repo: ngelrojas/fast_api_jwt
           echo "Requesting runner registration token from GitHub API..."

           # Make the API call and capture both response and HTTP status
           http_response=$(curl -s -w "\n%{http_code}" -X POST \
             -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
             -H "Accept: application/vnd.github+json" \
             -H "X-GitHub-Api-Version: 2022-11-28" \
             https://api.github.com/repos/ngelrojas/fast_api_jwt/actions/runners/registration-token)

           # Extract HTTP status code (last line)
           http_code=$(echo "$http_response" | tail -n1)
           # Extract response body (all but last line)
           resp=$(echo "$http_response" | sed '$d')

           echo "HTTP Status Code: $http_code"
           echo "API Response Body:"
           echo "$resp"

           # Check HTTP status code
           if [ "$http_code" != "201" ]; then
             echo "ERROR: API request failed with HTTP status code $http_code"
             exit 1
           fi

           # Check if response contains an error message
           if echo "$resp" | grep -q '"message"'; then
             echo "ERROR: API returned an error response"
             echo "$resp" | python3 -c "import sys,json; data=json.load(sys.stdin); print('Error:', data.get('message', 'Unknown error'))"
             exit 1
           fi

           # Extract token with better error handling
           token=$(echo "$resp" | python3 -c "import sys,json; data=json.load(sys.stdin); print(data.get('token', ''))")

           if [ -z "$token" ]; then
             echo "ERROR: Failed to extract token from API response"
             echo "Response was: $resp"
             exit 1
           fi

           echo "Token length: ${#token}"
           echo "token=$token" >> $GITHUB_OUTPUT
           echo "Token successfully generated and stored in output"

      - name: Debug Generated Token
        run: |
          TOKEN="${{ steps.create_token.outputs.token }}"
          if [ -z "$TOKEN" ]; then
            echo "ERROR: Generated token is NOT set or is empty!"
            exit 1
          else
            echo "DEBUG: Token is present (length: ${#TOKEN})"
            echo "DEBUG: Token first 10 chars: ${TOKEN:0:10}..."
            echo "DEBUG: Token will be passed to Terraform"
          fi

      - name: Provision EC2 Self Hosted Runner Plan
        working-directory: terraform/production/ec2-self-hosted
        env:
          TF_VAR_github_token: ${{ steps.create_token.outputs.token }}
        run: |
          TOKEN="${{ steps.create_token.outputs.token }}"
          echo "DEBUG: Verifying token before plan..."
          if [ -z "$TOKEN" ]; then
            echo "ERROR: Token is empty before plan!"
            exit 1
          fi
          echo "DEBUG: Token length: ${#TOKEN}"
          echo "DEBUG: Token first 10 chars: ${TOKEN:0:10}..."
          echo "DEBUG: TF_VAR_github_token is set: $([ -n "$TF_VAR_github_token" ] && echo "YES" || echo "NO")"
          echo "DEBUG: Running terraform plan with github_token variable..."
          terraform plan -out=tfplan -var="github_token=$TOKEN"

      - name: Import existing EC2 Self Hosted Runner resources if needed and apply
        working-directory: terraform/production/ec2-self-hosted
        env:
          TF_VAR_github_token: ${{ steps.create_token.outputs.token }}
        run: |
          echo "Checking for EC2 Self Hosted Runner resources that need to be imported..."

          # Check and import security group
          if terraform state show "aws_security_group.github_actions_runner" &>/dev/null; then
            echo "✓ Security group already in Terraform state"
          else
            echo "→ Security group not in state, checking AWS..."
            SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=github-actions-runner-sg" --query "SecurityGroups[0].GroupId" --output text 2>/dev/null)
            if [ "$SG_ID" != "None" ] && [ -n "$SG_ID" ]; then
              echo "→ Found security group $SG_ID in AWS, importing..."
              terraform import aws_security_group.github_actions_runner "$SG_ID" || echo "⚠ Security group import failed"
            else
              echo "→ Security group doesn't exist in AWS, will be created"
            fi
          fi

          # Check and import EC2 instance
          if terraform state show "aws_instance.github_actions_runner" &>/dev/null; then
            echo "✓ EC2 instance already in Terraform state"
          else
            echo "→ EC2 instance not in state, checking AWS..."
            INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=github-actions-self-hosted" "Name=instance-state-name,Values=running,stopped" --query "Reservations[0].Instances[0].InstanceId" --output text 2>/dev/null)
            if [ "$INSTANCE_ID" != "None" ] && [ -n "$INSTANCE_ID" ]; then
              echo "→ Found instance $INSTANCE_ID in AWS, importing..."
              terraform import aws_instance.github_actions_runner "$INSTANCE_ID" || echo "⚠ Instance import failed"
            else
              echo "→ EC2 instance doesn't exist in AWS, will be created"
            fi
          fi

          TOKEN="${{ steps.create_token.outputs.token }}"
          echo "Import checks completed. Applying changes with GitHub token..."
          echo "DEBUG: Token is set: $([ -n "$TOKEN" ] && echo "YES (length: ${#TOKEN})" || echo "NO")"
          echo "DEBUG: TF_VAR_github_token is set: $([ -n "$TF_VAR_github_token" ] && echo "YES" || echo "NO")"
          terraform apply -auto-approve -var="github_token=$TOKEN"
