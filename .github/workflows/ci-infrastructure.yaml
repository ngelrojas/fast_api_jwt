name: 2 - Provisioning Infrastructure

on:
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  pull-requests: write
  security-events: write
  actions: write
  checks: write
  issues: write

jobs:
  iam:
    name: Provisioning Permissions IAM
    runs-on: ubuntu-latest
    environment: prd
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.13

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AW_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: ${{ secrets.AWS_STS }}
          role-session-name: GitHubActions-${{github.run_id}}

      - name: Terraform Format Check IAM
        uses: dflook/terraform-fmt-check@v1
        with:
          path: terraform/production/iam

      - name: Remove problematic IAM resource from Terraform state (customize resource address)
        working-directory: terraform/production/iam
        run: |
          # Replace aws_iam_policy.example with your actual resource address
          terraform state rm aws_iam_policy.example || echo "Resource not in state, skipping."

      - name: Provision Permissions IAM Initial Setup
        working-directory: terraform/production/iam
        run: terraform init -input=false -no-color

      - name: Provision Permissions Plan (with error output)
        working-directory: terraform/production/iam
        run: |
          terraform plan -out=tfplan || (echo "Plan failed, see above for details." && exit 1)

      - name: Provision IAM Permissions Apply (with error output)
        working-directory: terraform/production/iam
        run: |
          terraform apply -auto-approve || (echo "Apply failed, see above for details." && exit 1)
      # Manual rollback: If a resource fails, you can run
      # terraform destroy -target=<resource_address> in the working directory to clean up.
  sqs:
    name: Provisioning SQS Infrastructure
    runs-on: ubuntu-latest
    environment: prd
    needs: iam
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.13

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AW_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: ${{ secrets.AWS_STS }}
          role-session-name: GitHubActions-${{github.run_id}}

      - name: Terraform Format Check SQS
        uses: dflook/terraform-fmt-check@v1
        with:
          path: terraform/production/sqs-notifications

      - name: Provision SQS Initial Setup
        working-directory: terraform/production/sqs-notifications
        run: terraform init -input=false -no-color
      - name: Provision SQS Plan
        working-directory: terraform/production/sqs-notifications
        run: terraform plan -out=tfplan
      - name: Provision SQS Apply
        working-directory: terraform/production/sqs-notifications
        run: terraform apply -auto-approve

  s3:
    name: Provisioning S3 Bucket
    runs-on: ubuntu-latest
    environment: prd
    needs: iam
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.13

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AW_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: ${{ secrets.AWS_STS }}
          role-session-name: GitHubActions-${{github.run_id}}

      - name: Terraform Format Check S3
        uses: dflook/terraform-fmt-check@v1
        with:
          path: terraform/production/s3-storage

      - name: Provision S3 Initial Setup
        working-directory: terraform/production/s3-storage
        run: terraform init -input=false -no-color

      - name: Provision S3 Plan
        working-directory: terraform/production/s3-storage
        run: terraform plan -out=tfplan

      - name: Provision S3 Apply
        working-directory: terraform/production/s3-storage
        run: terraform apply -auto-approve

  secreter-manager-fast-api:
    name: Provisioning Secrets Manager Fast API Infrastructure
    runs-on: ubuntu-latest
    environment: prd
    needs: iam
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.13

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AW_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: ${{ secrets.AWS_STS }}
          role-session-name: GitHubActions-${{github.run_id}}

      - name: Terraform Format Check Secrets Manager Fast API
        uses: dflook/terraform-fmt-check@v1
        with:
          path: terraform/production/secret-manager

      - name: Provision Secret manager Initial Setup
        working-directory: terraform/production/secret-manager
        run: terraform init -input=false -no-color
      - name: Provision Secret manager Plan
        working-directory: terraform/production/secret-manager
        run: terraform plan -out=tfplan
      - name: Provision Secret manager Apply
        working-directory: terraform/production/secret-manager
        run: terraform apply -auto-approve

  ec2-fast-api:
    name: Provisioning EC2 Fast API Infrastructure
    runs-on: ubuntu-latest
    environment: prd
    needs: [iam, secreter-manager-fast-api]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.13

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AW_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: ${{ secrets.AWS_STS }}
          role-session-name: GitHubActions-${{github.run_id}}

      - name: Terraform Format Check EC2 Fast API
        uses: dflook/terraform-fmt-check@v1
        with:
          path: terraform/production/ec2-fast-api-jwt
      - name: Provision EC2 Fast API Initial Setup
        working-directory: terraform/production/ec2-fast-api-jwt
        run: terraform init -input=false -no-color
      - name: Provision EC2 Fast API Plan
        working-directory: terraform/production/ec2-fast-api-jwt
        run: terraform plan -out=tfplan
      - name: Provision EC2 Fast API Apply
        working-directory: terraform/production/ec2-fast-api-jwt
        run: terraform apply -auto-approve

  ec2-self-hosted:
    name: Provisioning EC2 Self Hosted Runner Infrastructure
    runs-on: ubuntu-latest
    environment: prd
    needs: iam
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.13

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AW_ROLE }}
          aws-region: ${{ secrets.AWS_REGION }}
          audience: ${{ secrets.AWS_STS }}
          role-session-name: GitHubActions-${{github.run_id}}

      - name: Terraform Format Check EC2 Self Hosted Runner
        uses: dflook/terraform-fmt-check@v1
        with:
          path: terraform/production/ec2-self-hosted
      - name: Provision EC2 Self Hosted Runner Initial Setup
        working-directory: terraform/production/ec2-self-hosted
        run: terraform init -input=false -no-color

      - name: Provision EC2 Self Hosted Runner Plan
        working-directory: terraform/production/ec2-self-hosted
        run: terraform plan -out=tfplan

      - name: Create runner registration token
        id: create_token
        run: |
           # Request a repository-level registration token for repo: ngelrojas/fast_api_jwt
           echo "Requesting runner registration token from GitHub API..."

           # Make the API call and capture both response and HTTP status
           http_response=$(curl -s -w "\n%{http_code}" -X POST \
             -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
             -H "Accept: application/vnd.github+json" \
             -H "X-GitHub-Api-Version: 2022-11-28" \
             https://api.github.com/repos/ngelrojas/fast_api_jwt/actions/runners/registration-token)

           # Extract HTTP status code (last line)
           http_code=$(echo "$http_response" | tail -n1)
           # Extract response body (all but last line)
           resp=$(echo "$http_response" | sed '$d')

           echo "HTTP Status Code: $http_code"
           echo "API Response Body:"
           echo "$resp"

           # Check HTTP status code
           if [ "$http_code" != "201" ]; then
             echo "ERROR: API request failed with HTTP status code $http_code"
             exit 1
           fi

           # Check if response contains an error message
           if echo "$resp" | grep -q '"message"'; then
             echo "ERROR: API returned an error response"
             echo "$resp" | python3 -c "import sys,json; data=json.load(sys.stdin); print('Error:', data.get('message', 'Unknown error'))"
             exit 1
           fi

           # Extract token with better error handling
           token=$(echo "$resp" | python3 -c "import sys,json; data=json.load(sys.stdin); print(data.get('token', ''))")

           if [ -z "$token" ]; then
             echo "ERROR: Failed to extract token from API response"
             echo "Response was: $resp"
             exit 1
           fi

           echo "Token length: ${#token}"
           echo "token=$token" >> $GITHUB_OUTPUT
           echo "Token successfully generated and stored in output"

      - name: Debug Generated Token
        run: |
          TOKEN="${{ steps.create_token.outputs.token }}"
          if [ -z "$TOKEN" ]; then
            echo "ERROR: Generated token is NOT set or is empty!"
            exit 1
          else
            echo "DEBUG: Token is present (length: ${#TOKEN})"
            echo "DEBUG: Token will be passed to Terraform"
          fi
      - name: Provision EC2 Self Hosted Runner Apply
        working-directory: terraform/production/ec2-self-hosted
        run: terraform apply -auto-approve -var="github_token=${{ steps.create_token.outputs.token }}"
